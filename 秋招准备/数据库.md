### 范式

**1NF：每个属性都不可再分**（e.g. 销售额=件数*单价）

**2NF：消除了非主属性对于码的部分函数依赖。**（非主属性即码以外的属性，只要非主属性可以由码的一部分决定，那就不符合2NF；从而，如果码只有一个属性，那么必定满足2NF）

**3NF：消除了非主属性对于码的传递函数依赖。**

**BCNF：消除了主属性对于码的部分和传递函数依赖。**

![范式](./图片/范式.jpg)



### 索引

**索引**是帮助MySQL高效获取数据的**排好序**的**数据结构**

索引数据结构

- 二叉树
- 红黑树
- Hash表
- B树

红黑树缺点：数据量大时树太高，一个结点只放一个数，随机IO多

B+树：

- 非叶子节点不存储data，只存储索引（冗余），可以放更多索引
- 叶子节点包含所有索引字段
- 叶子节点用指针连接，提高区间访问的性能（MySQL中是双向指针）

MySQL每个页默认为16KB，一个页可以放1000+个元素（一个bigint8字节，一个指针6字节）

![B+树结构](./图片/B+.png)

**B树和B+树的区别：**

- B树的非叶子节点既存储索引（指针）也存储数据
- B树的叶子节点间没有指针连接

 

**Hash**

- 对索引的key进行一次hash计算就可以定位出数据存储的位置
- 很多时候Hash索引要比B+树索引更高效
- 仅能满足“=”、“IN”，**不支持范围查询**（不常使用Hash索引的主要原因）
- hash冲突问题：解决办法：
  - 链地址法：对于相同的哈希值，使用链表进行连接。（**HashMap使用此法**）
  - 再哈希法：提供多个哈希函数，如果第一个哈希函数计算出来的key的哈希值冲突了，则使用第二个哈希函数计算key的哈希值。
  - 建立公共溢出区：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。
  - 开放定址法


 

MyIASM引擎，B+树的数据结构中存储的内容实际上是实际数据的地址值。也就是说它的索引和实际数据是分开的，只不过使用索引指向了实际数据。这种索引的模式被称为**非聚集索引**。

Innodb引擎的索引的数据结构也是B+树，只不过叶子节点中存储的都是实际的数据，这种索引有被称为**聚集索引**。非主键索引结构叶子节点存储的是主键值，所以建议InnoDB表必须建主键（否则会自动建），并且推荐使用整型的自增主键（自增使得插入的时候只会在叶子节点链最后插入，如果要插入到中间，可能会引起索引树的大量调整）。

 

**索引的分类**

- 主键索引：唯一性索引
- 唯一索引：索引列的所有值都只能出现一次
- 普通索引：基本的索引类型，值可以为空，没有唯一性的限制。
- 全文索引：FULLTEXT，可以在varchar、char、text类型的列上创建
- 组合索引：多列值组成一个索引，专门用于组合搜索。

 

**组合索引**

最左前缀原则





### 事务的特性

#### 原子性（atomicity)

&emsp;&emsp;一个事务要么全部提交成功，要么全部失败回滚，不能只执行其中的一部分操作，这就是事务的原子性

#### 一致性（consistency)

&emsp;&emsp;事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。
&emsp;&emsp;如果数据库系统在运行过程中发生故障，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所作的修改有一部分已写入物理数据库，这是数据库就处于一种不正确的状态，也就是不一致的状态

#### 隔离性（isolation）

&emsp;&emsp;事务的隔离性是指在并发环境中，并发的事务时相互隔离的，一个事务的执行不能不被其他事务干扰。不同的事务并发操作相同的数据时，每个事务都有各自完成的数据空间，即一个事务内部的操作及使用的数据对其他并发事务时隔离的，并发执行的各个事务之间不能相互干扰。

#### 持久性（durability）

&emsp;&emsp;一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中。--即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束的状态。





### 杂项

#### count(1|*|字段) 的区别

**从执行结果来说：**

count（1）和count（*）之间没有区别，因为count（*）count（1）都不会去过滤空值，但count（列名）就有区别了，因为count（列名）会去过滤空值。

从执行效率来说：

​     他们之间根据不同情况会有些许区别，MySQL会对count（*）做优化。

​     （1）如果列为[主键](https://so.csdn.net/so/search?q=主键&spm=1001.2101.3001.7020)，count(列名)效率优于count(1)  

​     （2）如果列不为主键，count(1)效率优于count(列名)  

​     （3）如果表中存在主键，count(主键列名)效率最优  

​     （4）如果表中只有一列，则count(*)效率最优  

​     （5）如果表有多列，且不存在主键，则count(1)效率优于count(*)


补充：

count(1)，其实就是计算一共有多少符合条件的行。

1并不是表示第一个字段，而是表示一个固定值。

其实就可以想成表中有这么一个字段，这个字段就是固定值1，count(1)，就是计算一共有多少个1。

count(*)，执行时会把星号翻译成字段的具体名字，效果也是一样的，不过多了一个翻译的动作，比固定值的方式效率稍微低一些。



#### 数据切分（水平切分、垂直切分）

概念：指通过某种特定的条件，将同一个数据库中的数据分散存放到多个数据库（主机）上面，达到分散单台设备负载的效果。

1. **垂直拆分**

   按照不同的表（或者Schema）切分到不同的数据库（主机）上。一个数据库由很多表构成，每张表对应不同的业务，垂直切分是按照业务将表进行分类，分布到不同数据库上。

   优点：

   - 拆分后业务清晰，拆分规则明确
   - 系统间整合或扩展容易
   - 数据维护简单

    缺点：

   - 部分业务表（很难独立）无法join  ，只能通过接口方式解决，提高系统复杂度
   - 受每种业务不同的限制存在单库性能瓶颈，不易数据扩展和性能提高
   - 事务处理复杂

2. **水平切分**

   根据表中数据的逻辑关系，将同一个表中的数据按照某种条件拆分到多台数据库（主机）上。

   几种典型的分片规则包括：

   - 按照用户ID求模，将数据分散到不同库，相同数据用户的数据被分到一个库中
   - 按照日期划分
   - 按照某个特定字段求模或根据特定范围划分

   优点：

   - 拆分规则抽象好，数据库可以做join操作
   - 不存在单库大数据，高并发的性能瓶颈
   - 应用端改造较少
   - 提高了系统的稳定性和负载能力

   缺点：

   - 拆分规则难以抽象
   - 分片事务一致性难以解决
   - 数据多次扩展难度和维护量极大
   - 跨库join性能较差

