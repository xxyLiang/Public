>## 并发控制的两阶段加锁技术

#### 二进制锁
- 两个状态：已加锁和未加锁，简化为0和1
- 两个操作：lock_item和unlock_item
- 缺陷：并发性能差

#### 读/写锁
- 三个状态：read_locked, write_locked, unlocked
- read_locked可以同时被多个事务使用，write_locked只能同时被一个事务使用

**使用二进制锁或读/写锁，不能保证调度的可串行性**

>#### 通过两阶段加锁保证可串行性
**两阶段加锁协议(2PL)**：事务中的所有加锁操作都要先于第一个解锁操作。
事务可以分为两个阶段：
1. 扩展或增长阶段（第一阶段）：可以获得数据项的新锁，但是不能释放任何已持有的锁。
2. 收缩阶段（第二阶段）：可以释放已持有的锁，但是不能获得新锁

如果调度中的每个事务都遵循两阶段加锁规则，则可以保证事务可串行性。

二阶段加锁（2PL）的变种：
- 保守2PL或静态2PL：要求事务在开始执行前要**预声明其读集合和写集合**，然后所有都加上锁
- 严格2PL
- 精确2PL

>#### 死锁和饥饿状态

死锁：一组相互竞争系统资源或进行通信的进程间的“永久”阻塞。当一组进程中的每个进程都在等待某个时间，而只有这组进程中的其他被阻塞的进程才可以触发该时间，这时这组进程发生死锁。
死锁的四个条件：
1. 互斥。一次只有一个进程可以使用一个资源。其他进程不能访问已分配给其他进程的资源。
2. 占有且等待。当一个进程等待其他进程时，继续占有已经分配的资源。
3. 不可抢占。不能强行抢占进程已占有的资源。
4. 循环等待。存在一个封闭的进程链，使得每个进程至少占有此链中下个进程所需的一个资源。

死锁的预防：
1. 破坏“占有并等待”条件：
   - 破坏“占有并等待”条件，就是在系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，阻止进程在持有资源的同时申请其他资源。
   - 方法一：创建进程时，要求它申请所需的全部资源，系统或满足其所有要求，或么什么也不给它。这是所谓的“**一次性分配**”方案。
   - 方法二：要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源S时，须先把它先前占有的资源R释放掉，然后才能提出对S的申请，即使它可能很快又要用到资源R。

2. 破坏“不可抢占”条件
    - 破坏“不可抢占”条件，就是允许对资源实行抢夺。
    - 方法一：如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。
    - 方法二：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不相同的条件下，方法二才能预防死锁。

3. 破坏“循环等待”条件

![死锁](https://images4.pianshen.com/918/c1/c12b93f8d4e1ae755a4c5d1e1405911e.png)

饥饿：当一个事务在不确定的时间段内不能继续执行，而系统中其它事务却可以正常进行时，就产生了饥饿。

解决饥饿的方法：
1. 使用公平等待模式
2. 使用优先级模式

<br/>

## 作业
https://www.sslibrary.com/

mysql数据库应用教程 
8.2 事务并发与控制 （教程，开两个客户端）

> 第一题

mysql数据库应用与项目开发教程
项目八 事务与锁 实践题第一题

首先建表
```sql
CREATE TABLE `student`(
    `id` char(9) primary key, 
    `name` char(200) not null
    );
```
事务定义
```sql
use test;
delimiter %%
create procedure pro1()
begin
    declare continue handler for 1062
    begin
        rollback;
    end;
    start transaction;
    INSERT INTO `student` values('202010001', '张三');
    select count(`id`) into @num from `student` where `id`='202010001';
    if @num=1 then
        begin
            savepoint apoint;
            set @ch1 = '插入202010001成功';
        end;
    end if;
    delete from `student` where `id`='202010001';
    select count(`id`) into @num from `student` where `id`='202010001';
    if @num=0 then
        begin
            set @ch2 = '删除202010001成功';
            rollback;
        end;
    end if;
    select count(`id`) into @num from `student` where `id`='202010001';
    if @num=1 then
        begin
            set @result = '插入的数据仍存在';
        end;
    else 
        begin
            set @result = '插入的数据不存在';
        end;
    end if;
    commit;
end%%
delimiter ;
```
<br/>

> 第二题

数据库原理与设计实验及课程设计教程
P174  3、4题